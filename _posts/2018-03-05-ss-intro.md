---
layout: post
comments: true
share: true
title: Shadowsocks 系列 -- 簡介
date: 2018-03-05 04:00:00
description: shadowsocks 介绍
tags: 
 - ss
---

Shadowsocks 是一個能騙過防火墻的網絡代理工具。它把要傳輸的原數據經過加密後再傳輸，網絡中的防火墻由於得不出要傳輸的原內容是什麽而只好放行，於是就完成了防火墻穿透，也即是所謂的“翻墻”。

在自由的網絡環境下，在本機上訪問服務時是直接和遠程服務建立連接傳輸數據，流程如圖：

![](http://telegra.ph/file/866e1fb47e92380c2bb73.png)*自由網絡環境下的傳輸流程*

但在受限的網絡環境下會有防火墻，本機電腦和遠程服務之間傳輸的數據都必須通過防火墻的檢查，流程如圖：

![](http://telegra.ph/file/7bdd280b594c86930b8b9.png)*受限網絡環境下的傳輸流程*

如果防火墻發現你在傳輸受限的內容，就把攔截本次傳輸，就會導致在本機無法訪問遠程服務。

而 Shadowsocks 所做的就是把傳輸的數據加密，防火墻得到的數據是加密後的數據，防火墻不知道傳輸的原內容是什麽，於是防火墻就放行本次請求，於是在本機就訪問到了遠程服務，流程如圖：

![](http://telegra.ph/file/82ad34cffa424675522ce.png)*shadowsocks下的傳輸流程*

也就是說使用 Shadowsocks 的前提是：

1. 一臺在防火墻之外的服務器；
2. 在本機需要安裝 Shadowsocks 本地端，用於加密傳輸數據；
3. 服務器需要安裝 Shadowsocks 服務端，用於解密加密後的傳輸數據，解密出原數據後發送到目標服務器。

> **Shadowsocks 原理**

Shadowsocks 由兩部分組成，運行在本地的 `ss-local` 和運行在防火墻之外服務器上的 `ss-server`，下面來分別詳細介紹它們的職責（以下對 Shadowsocks 原理的解析只是我的大概估計，可能會有細微的差別）。

ss-local 的職責是在本機啟動和監聽著一個服務，本地軟件的網絡請求都先發送到 `ss-local`，`ss-local` 收到來自本地軟件的網絡請求後，把要傳輸的原數據根據用戶配置的加密方法和密碼進行加密，再轉發到墻外的服務器去。

`ss-server` 的職責是在墻外服務器啟動和監聽一個服務，該服務監聽來自本機的 `ss-local` 的請求。在收到來自 `ss-local` 轉發過來的數據時，會先根據用戶配置的加密方法和密碼對數據進行對稱解密，以獲得加密後的數據的原內容。同時還會解 SOCKS5 協議，讀出本次請求真正的目標服務地址(例如 Google 服務器地址)，再把解密後得到的原數據轉發到真正的目標服務。

當真正的目標服務返回了數據時，`ss-server` 端會把返回的數據加密後轉發給對應的 `ss-local` 端，`ss-local` 端收到數據再解密後，轉發給本機的軟件。這是一個對稱相反的過程。

由於 `ss-local` 和 `ss-server` 端都需要用對稱加密算法對數據進行加密和解密，因此這兩端的加密方法和密碼必須配置為一樣。Shadowsocks 提供了一系列標準可靠的對稱算法可供用戶選擇，例如 `rc4`、`aes`、`des`、`chacha20` 等等。Shadowsocks 對數據加密後再傳輸的目的是為了混淆原數據，讓途中的防火墻無法得出傳輸的原數據。但其實用這些安全性高計算量大的對稱加密算法去實現混淆有點“殺雞用牛刀”。

---

## Shadowsocks 系列

1. [Shadowsocks 簡介](https://test007.gq/ss-intro) \ 本文地址
2. Shadowsocks Windows 客戶端的單步指導請參考[這篇文章](https://test007.gq/ss-cmd)
3. Shadowsocks 各平臺客戶端[下載頁面](https://test007.gq/ss-download)

**(。・∀・)ノ - (。・∀・)ノ - (。・∀・)ノ**

![](http://telegra.ph/file/266899c5402c9ebb14269.png){:.qrcode}

感謝每位聽衆，每個靈魂。

**(。・∀・)ノ - (。・∀・)ノ - (。・∀・)ノ**
