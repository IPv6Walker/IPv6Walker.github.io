---
layout: post
comments: true
share: true
title: Shadowsocks 簡介
date: 2018-03-05 04:00:00
description: shadowsocks 各平臺下載匯總
tags: 
 - ss
---

> 寫給非專業人士看的 Shadowsocks 簡介 #

這個文章來源於一個朋友在科學上網的過程中，搞不清楚 Shadowsocks 的配置問題，在這裏我想按照我對 Shadowsocks 的理解簡單梳理一下，以便一些非專業人士也能了解

long long ago…
在很久很久以前，我們訪問各種網站都是簡單而直接的，用戶的請求通過互聯網發送到服務提供方，服務提供方直接將信息反饋給用戶

![](http://telegra.ph/file/866e1fb47e92380c2bb73.png)

when evil comes
然後有一天，GFW 就出現了，他像一個收過路費的強盜一樣夾在了在用戶和服務之間，每當用戶需要獲取信息，都經過了 GFW，GFW將它不喜歡的內容統統過濾掉，於是客戶當觸發 GFW 的過濾規則的時候，就會收到 Connection Reset 這樣的響應內容，而無法接收到正常的內容

![](http://telegra.ph/file/7bdd280b594c86930b8b9.png)

ssh tunnel
聰明的人們想到了利用境外服務器代理的方法來繞過 GFW 的過濾，其中包含了各種HTTP代理服務、Socks服務、VPN服務… 其中以 ssh tunnel 的方法比較有代表性

1. 首先用戶和境外服務器基於 ssh 建立起一條加密的通道 
2. 用戶通過建立起的隧道進行代理，通過 ssh server 向真實的服務發起請求
3. 服務通過 ssh server，再通過創建好的隧道返回給用戶

![](http://telegra.ph/file/6f851c0fb0ed4cebdc7c9.png){:.center-image}

由於 ssh 本身就是基於 RSA 加密技術，所以 GFW 無法從數據傳輸的過程中的加密數據內容進行關鍵詞分析，避免了被重置鏈接的問題，但由於創建隧道和數據傳輸的過程中，ssh 本身的特征是明顯的，所以 GFW 一度通過分析連接的特征進行幹擾，導致 ssh 存在被定向進行幹擾的問題

shadowsocks
於是 clowwindy 同學分享並開源了他的解決方案

![](http://telegra.ph/file/82ad34cffa424675522ce.png)

簡單理解的話，shadowsocks 是將原來 ssh 創建的 Socks5 協議拆開成 server 端和 client 端，所以下面這個原理圖基本上和利用 ssh tunnel 大致類似

1. 客戶端發出的請求基於 Socks5 協議跟 `ss-local`
2.  端進行通訊，由於這個 `ss-local` 一般是本機或路由器或局域網的其他機器，不經過 GFW，所以解決了上面被 GFW 通過特征分析進行幹擾的問題  
2. `ss-local` 和 `ss-server` 兩端通過多種可選的加密方法進行通訊，經過 GFW 的時候是常規的TCP包，沒有明顯的特征碼而且 GFW 也無法對通訊數據進行解密  
3. `ss-server` 將收到的加密數據進行解密，還原原來的請求，再發送到用戶需要訪問的服務，獲取響應原路返回 

**(●ˇ∀ˇ●) - (●ˇ∀ˇ●) - 技術深淺分割線 - (●ˇ∀ˇ●) - (●ˇ∀ˇ●)**

> 進一步認識 Shadowsocks ##

Shadowsocks 是一個能騙過防火墻的網絡代理工具。它把要傳輸的原數據經過加密後再傳輸，網絡中的防火墻由於得不出要傳輸的原內容是什麽而只好放行，於是就完成了防火墻穿透，也即是所謂的“翻墻”。

在自由的網絡環境下，在本機上訪問服務時是直接和遠程服務建立連接傳輸數據，流程如圖：

![](http://telegra.ph/file/866e1fb47e92380c2bb73.png)*自由網絡環境下的傳輸流程*

但在受限的網絡環境下會有防火墻，本機電腦和遠程服務之間傳輸的數據都必須通過防火墻的檢查，流程如圖：

![](http://telegra.ph/file/7bdd280b594c86930b8b9.png)*受限網絡環境下的傳輸流程*

如果防火墻發現你在傳輸受限的內容，就把攔截本次傳輸，就會導致在本機無法訪問遠程服務。

而 Shadowsocks 所做的就是把傳輸的數據加密，防火墻得到的數據是加密後的數據，防火墻不知道傳輸的原內容是什麽，於是防火墻就放行本次請求，於是在本機就訪問到了遠程服務，流程如圖：

![](http://telegra.ph/file/82ad34cffa424675522ce.png)*shadowsocks下的傳輸流程*

也就是說使用 Shadowsocks 的前提是：

1. 一臺在防火墻之外的服務器；
2. 在本機需要安裝 Shadowsocks 本地端，用於加密傳輸數據；
3. 服務器需要安裝 Shadowsocks 服務端，用於解密加密後的傳輸數據，解密出原數據後發送到目標服務器。

> Shadowsocks 原理 ###

Shadowsocks 由兩部分組成，運行在本地的 `ss-local` 和運行在防火墻之外服務器上的 `ss-server`，下面來分別詳細介紹它們的職責（以下對 Shadowsocks 原理的解析只是我的大概估計，可能會有細微的差別）。

ss-local 的職責是在本機啟動和監聽著一個服務，本地軟件的網絡請求都先發送到 `ss-local`，`ss-local` 收到來自本地軟件的網絡請求後，把要傳輸的原數據根據用戶配置的加密方法和密碼進行加密，再轉發到墻外的服務器去。

`ss-server` 的職責是在墻外服務器啟動和監聽一個服務，該服務監聽來自本機的 `ss-local` 的請求。在收到來自 `ss-local` 轉發過來的數據時，會先根據用戶配置的加密方法和密碼對數據進行對稱解密，以獲得加密後的數據的原內容。同時還會解 SOCKS5 協議，讀出本次請求真正的目標服務地址(例如 Google 服務器地址)，再把解密後得到的原數據轉發到真正的目標服務。

當真正的目標服務返回了數據時，`ss-server` 端會把返回的數據加密後轉發給對應的 `ss-local` 端，`ss-local` 端收到數據再解密後，轉發給本機的軟件。這是一個對稱相反的過程。

由於 `ss-local` 和 `ss-server` 端都需要用對稱加密算法對數據進行加密和解密，因此這兩端的加密方法和密碼必須配置為一樣。Shadowsocks 提供了一系列標準可靠的對稱算法可供用戶選擇，例如 `rc4`、`aes`、`des`、`chacha20` 等等。Shadowsocks 對數據加密後再傳輸的目的是為了混淆原數據，讓途中的防火墻無法得出傳輸的原數據。但其實用這些安全性高計算量大的對稱加密算法去實現混淆有點“殺雞用牛刀”。

更多關於 ss ->

1. [Shadowsocks 簡介](http://test007.gq/ss-intro) \ 本文地址
2. Shadowsocks Windows 客戶端的單步指導請參考[這篇文章](http://test007.gq/ss-cmd)
3. Shadowsocks 各平臺客戶端[下載頁面](http://test007.gq/ss-download)

### 更多

1. 關於代理上網，請參考[機智上網](http://test007.gq/surf-the-real)
2. [Telegram 入門](http://test007.gq/Telegram)
3. [利用教育網 IPv6 實現免代理翻墻、大一斷網和夜間斷網破解](http://test007.gq/IPV6-edu)
4. [IPv6 節點獲取](http://test007.gq/IPV6-node)

(。・∀・)ノ - (。・∀・)ノ - (。・∀・)ノ - (。・∀・)ノ